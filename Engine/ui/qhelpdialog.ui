<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>QHelpDialog</class>
 <widget class="QDialog" name="QHelpDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>875</width>
    <height>609</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="1" column="1">
    <widget class="QPushButton" name="btn_ok">
     <property name="minimumSize">
      <size>
       <width>100</width>
       <height>30</height>
      </size>
     </property>
     <property name="maximumSize">
      <size>
       <width>200</width>
       <height>16777215</height>
      </size>
     </property>
     <property name="font">
      <font>
       <family>Ubuntu Mono</family>
       <pointsize>14</pointsize>
       <italic>true</italic>
       <bold>false</bold>
      </font>
     </property>
     <property name="text">
      <string>OK</string>
     </property>
    </widget>
   </item>
   <item row="1" column="0">
    <spacer name="horizontalSpacer">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>40</width>
       <height>20</height>
      </size>
     </property>
    </spacer>
   </item>
   <item row="1" column="2">
    <spacer name="horizontalSpacer_2">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="sizeType">
      <enum>QSizePolicy::Fixed</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>40</width>
       <height>20</height>
      </size>
     </property>
    </spacer>
   </item>
   <item row="0" column="0" colspan="3">
    <widget class="QFrame" name="frame">
     <property name="font">
      <font>
       <family>Ubuntu Mono</family>
       <pointsize>14</pointsize>
       <italic>true</italic>
       <bold>false</bold>
      </font>
     </property>
     <property name="frameShape">
      <enum>QFrame::NoFrame</enum>
     </property>
     <property name="frameShadow">
      <enum>QFrame::Raised</enum>
     </property>
     <layout class="QGridLayout" name="gridLayout_2">
      <item row="0" column="0">
       <widget class="QToolBox" name="toolBox">
        <property name="font">
         <font>
          <family>Ubuntu Mono</family>
          <pointsize>14</pointsize>
          <italic>true</italic>
          <bold>true</bold>
         </font>
        </property>
        <property name="frameShape">
         <enum>QFrame::NoFrame</enum>
        </property>
        <property name="lineWidth">
         <number>1</number>
        </property>
        <property name="currentIndex">
         <number>1</number>
        </property>
        <property name="tabSpacing">
         <number>6</number>
        </property>
        <widget class="QWidget" name="main">
         <property name="geometry">
          <rect>
           <x>0</x>
           <y>0</y>
           <width>839</width>
           <height>405</height>
          </rect>
         </property>
         <attribute name="label">
          <string>Main</string>
         </attribute>
         <layout class="QGridLayout" name="gridLayout_6">
          <item row="0" column="0">
           <layout class="QHBoxLayout" name="horizontalLayout">
            <item>
             <widget class="QLabel" name="label_Q">
              <property name="minimumSize">
               <size>
                <width>120</width>
                <height>120</height>
               </size>
              </property>
              <property name="text">
               <string>TextLabel</string>
              </property>
              <property name="alignment">
               <set>Qt::AlignCenter</set>
              </property>
             </widget>
            </item>
            <item>
             <widget class="QLabel" name="label_R">
              <property name="minimumSize">
               <size>
                <width>120</width>
                <height>120</height>
               </size>
              </property>
              <property name="text">
               <string>TextLabel</string>
              </property>
              <property name="alignment">
               <set>Qt::AlignCenter</set>
              </property>
             </widget>
            </item>
            <item>
             <widget class="QLabel" name="label_G">
              <property name="minimumSize">
               <size>
                <width>120</width>
                <height>120</height>
               </size>
              </property>
              <property name="text">
               <string>TextLabel</string>
              </property>
              <property name="alignment">
               <set>Qt::AlignCenter</set>
              </property>
             </widget>
            </item>
            <item>
             <widget class="QLabel" name="label_B">
              <property name="minimumSize">
               <size>
                <width>120</width>
                <height>120</height>
               </size>
              </property>
              <property name="text">
               <string>TextLabel</string>
              </property>
              <property name="alignment">
               <set>Qt::AlignCenter</set>
              </property>
             </widget>
            </item>
            <item>
             <widget class="QLabel" name="label_D">
              <property name="minimumSize">
               <size>
                <width>120</width>
                <height>120</height>
               </size>
              </property>
              <property name="text">
               <string>TextLabel</string>
              </property>
              <property name="alignment">
               <set>Qt::AlignCenter</set>
              </property>
             </widget>
            </item>
           </layout>
          </item>
         </layout>
        </widget>
        <widget class="QWidget" name="overview">
         <property name="geometry">
          <rect>
           <x>0</x>
           <y>0</y>
           <width>839</width>
           <height>405</height>
          </rect>
         </property>
         <attribute name="label">
          <string>1. Overview</string>
         </attribute>
         <layout class="QGridLayout" name="gridLayout_3">
          <item row="0" column="0">
           <widget class="QTextBrowser" name="textBrowser">
            <property name="html">
             <string>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
p, li { white-space: pre-wrap; }
&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Ubuntu Mono'; font-size:14pt; font-weight:700; font-style:italic;&quot;&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-weight:400;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot; color:#ef2929;&quot;&gt;Slam&lt;/span&gt;&lt;span style=&quot; font-weight:400;&quot;&gt; (simultaneous localization and mapping), also known as &lt;/span&gt;&lt;span style=&quot; color:#ef2929;&quot;&gt;CML&lt;/span&gt;&lt;span style=&quot; font-weight:400;&quot;&gt; (concurrent mapping and localization), real-time positioning and map construction, or concurrent mapping and positioning. The problem can be described as: put a robot into an unknown position in an unknown environment, and whether there is a way for the robot to gradually draw a complete map of the environment while moving. The so-called a consistent map refers to walking to every corner of the room without obstacles.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-weight:400;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot; color:#ef2929;&quot;&gt;V-SLAM&lt;/span&gt;&lt;span style=&quot; font-weight:400;&quot;&gt; is a branch of slam. It takes the camera as the data acquisition equipment to locate and build maps in real time through relevant image and estimation optimization algorithms. Relying on a special camera rgbd camera, this project realizes slam software based on RGB image and depth image based on &lt;/span&gt;ORB-SLAM&lt;span style=&quot; font-weight:400;&quot;&gt; algorithm library, &lt;/span&gt;Yolo&lt;span style=&quot; font-weight:400;&quot;&gt; image recognition library and &lt;/span&gt;Open3D&lt;span style=&quot; font-weight:400;&quot;&gt; visualization library. It has the functions of location, scene recognition and scene reconstruction.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot; style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;img src=&quot;:/img/ros-server.png&quot; /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
            </property>
           </widget>
          </item>
         </layout>
        </widget>
        <widget class="QWidget" name="authors">
         <property name="geometry">
          <rect>
           <x>0</x>
           <y>0</y>
           <width>839</width>
           <height>405</height>
          </rect>
         </property>
         <attribute name="label">
          <string>2. Authors</string>
         </attribute>
         <layout class="QGridLayout" name="gridLayout_4">
          <item row="0" column="0">
           <widget class="QTextBrowser" name="textBrowser_2">
            <property name="html">
             <string>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
p, li { white-space: pre-wrap; }
&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Ubuntu Mono'; font-size:14pt; font-weight:700; font-style:italic;&quot;&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#fb8b00;&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;  &lt;span style=&quot; color:#ef2929;&quot;&gt;&amp;quot;developers&amp;quot;&lt;/span&gt;: &lt;span style=&quot; color:#ad7fa8;&quot;&gt;[&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;    &lt;span style=&quot; color:#729fcf;&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;      &lt;span style=&quot; color:#ef2929;&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;: &lt;span style=&quot; color:#4e9a06;&quot;&gt;&amp;quot;something&amp;quot;&lt;/span&gt;,&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;      &lt;span style=&quot; color:#ef2929;&quot;&gt;&amp;quot;e-mail&amp;quot;&lt;/span&gt;: &lt;span style=&quot; color:#4e9a06;&quot;&gt;&amp;quot;something&amp;quot;&lt;/span&gt;,&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;      &lt;span style=&quot; color:#ef2929;&quot;&gt;&amp;quot;school&amp;quot;&lt;/span&gt;: &lt;span style=&quot; color:#4e9a06;&quot;&gt;&amp;quot;something&amp;quot;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;    &lt;span style=&quot; color:#729fcf;&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;  &lt;span style=&quot; color:#ad7fa8;&quot;&gt;]&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#fb8b00;&quot;&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
            </property>
           </widget>
          </item>
         </layout>
        </widget>
        <widget class="QWidget" name="details">
         <property name="geometry">
          <rect>
           <x>0</x>
           <y>0</y>
           <width>839</width>
           <height>405</height>
          </rect>
         </property>
         <attribute name="label">
          <string>3. Details</string>
         </attribute>
         <layout class="QGridLayout" name="gridLayout_5">
          <item row="0" column="0">
           <widget class="QTextBrowser" name="textBrowser_3">
            <property name="html">
             <string>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
p, li { white-space: pre-wrap; }
&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Ubuntu Mono'; font-size:14pt; font-weight:700; font-style:italic;&quot;&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;    &lt;span style=&quot; font-weight:400;&quot;&gt;The workflow of the developed system is shown in the figure below. The solution method used this time is post-processing. The main process consists of two parts:&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;    &lt;span style=&quot; font-weight:400;&quot;&gt;1) Data acquisition: the Kinect camera is used to collect color images, depth images and IMU data at a certain frame rate. This         part is based on a small communication network composed of Ubuntu host, Android phone and Kinect camera. Through WiFi communication, Android phones send control signals to the Ubuntu host, receive data messages (including color images, depth images and IMU data) sent by the Ubuntu host, and display the data in real time on the user's Android selling price. The communication between Ubuntu and Kinect cameras is based on the ROS multi process communication mechanism. Specifically, Ubuntu will process the control messages sent by Android (such as start collection, stop collection, etc.) and convey them to the Kinect camera. The data collected by Kinect camera will be sent to Android via Ubuntu host for real-time display.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;    &lt;span style=&quot; font-weight:400;&quot;&gt;2) Data processing: that is, on Ubuntu, the qrgbd interface application developed based on QT is used to process and solve the collected data.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot; style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;img src=&quot;:/img/qrgbd-system-small.png&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#ef2929;&quot;&gt;    main interface thread&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;    &lt;span style=&quot; font-weight:400;&quot;&gt;The main interface thread completes the configuration of data to be processed, interactive control of processing flow, display and output of processing results and other functions. Specifically, the main interface thread obtains the path of the corresponding data through the configuration dialog window and reads it into memory when processing begins. At the beginning of processing, the data frame is sent to the slam thread at a certain frame rate to complete the slam process of the current frame and obtain the current pose. Then the pose and data frame are sent to the reconstruction thread for scene reconstruction. At the same time, when the recognition thread is idle, the color image is sent to the recognition thread for object recognition, and the marked image is obtained and displayed.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#ef2929;&quot;&gt;    slam thread&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;    &lt;span style=&quot; font-weight:400;&quot;&gt;Slam threads rely on the orb-slam3 library. When the main thread passes in the data frame, it performs the slam solution of the data frame. If the system has not been initialized, it will be initialized and then tracked. When the trace is lost, the slam system will try to relocate. If it fails, it will be reinitialized. After the related work is completed, the thread will return the calculated pose results to the main thread.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#ef2929;&quot;&gt;    identifying thread&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#ef2929;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot; font-weight:400;&quot;&gt;Identifying threads relies on the yolo3 library.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#ef2929;&quot;&gt;    rebuilding thread&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;    &lt;span style=&quot; font-weight:400;&quot;&gt;The reconstruction thread completes the remapping of depth map and the reconstruction of 3D scene. Since 3D scene reconstruction takes a lot of time, it is put into the sub thread of the reconstruction thread:&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;    &lt;span style=&quot; font-weight:400;&quot;&gt;1) Remapping of depth map: depth information of corresponding position pixels recorded in depth image acquired by rgbd camera. Because it is a single channel image, it is converted to a three channel RGB color image through remapping. After the remapping is completed, the resulting color image is returned to the main thread for visualization.&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;    &lt;span style=&quot; font-weight:400;&quot;&gt;2) 3D scene reconstruction: it relies on PCL library and is completed in sub threads. When the reconstruction thread converts the pixels on the depth map to the world coordinate system with the help of pose information and depth information, the point cloud data is obtained and sent to the 3D scene reconstruction sub thread. The 3D scene reconstruction sub thread visualizes the point cloud in an incremental manner. The 3D scene reconstruction sub thread has two visualization modes: interactive visualization and rendering visualization:&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;        &lt;span style=&quot; font-weight:400;&quot;&gt;a) Interactive visualization: when the slam is completed or terminated, the interactive visualization mode is enabled. Users can manipulate the PCL point cloud window through the mouse to view the point cloud from multiple angles and levels;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;        &lt;span style=&quot; font-weight:400;&quot;&gt;b) Rendering visualization: when slam is performed, the PCL window is performed in a rendering visualization manner. Specifically, visualize the point cloud to be incrementally visualized in each frame, track the position of the camera, and change the viewport to simulate the perspective during data collection.&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
            </property>
           </widget>
          </item>
         </layout>
        </widget>
       </widget>
      </item>
     </layout>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
